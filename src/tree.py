import re
from collections import deque

try:
    import tokenizer
except ImportError: # TODO: THIS IS UGLY
    from src import tokenizer

try:
    import expressions
except ImportError: # TODO: THIS IS UGLY
    from src import expressions




def buildProgram(filename):
    code = fetchfile('test.swarm')
    code = loadfile(code)
    code = tree(code)
    return Program(code)



class Node(object):
    def __init__(self,depth,code):
        self.depth = depth
        self.code = code
        self.parent = None
        self.children = []

    def add(self,child):
        child.parent = self
        self.children.append(child)

def fetchfile(filename):
    with open(filename,'r') as f:
        for line in f:
            yield line

# returns iterator of Node objects containing indent depth and line of code
def loadfile(it):
    '''
    >>> loadfile(['aaa','    bbb # comment  ','    ccc'])
    [(0, 'aaa'), (4, 'bbb'), (4, 'ccc')]
    '''

    code = []
    for line in it:
        match = re.match('^([ ]*)([^#\s\n][^#]*[^#\s\n])',line)
        if match:
            a,b = match.groups()
            code.append((len(a),tokenizer.tokenize(b)))
    return code

def tree(lines):
    '''
    folds stream of (indent,code) tuples into a tree

    returns a program-level node, parent to all 'agent' nodes
    >>> p = tree([(0, 'aaa'), (4, 'bbb'), (4, 'ccc')])
    >>> p.parent == None
    True

    >>> a = p.children[0]
    >>> a.depth == 0 and a.code == 'aaa'
    True
    >>> a.parent == p and len(a.children) == 2
    True

    >>> b = a.children[0]
    >>> b.depth == 4 and b.code == 'bbb'
    True
    >>> b.parent == a and b.children == []
    True

    >>> c = a.children[1]
    >>> c.depth == 4 and c.code == 'ccc'
    True
    >>> c.parent == a and c.children == []
    True
    '''

    root = Node(-4,'')
    ptr = root
    for depth,code in lines:
        line = Node(depth,code)

        if line.depth > ptr.depth:
            ptr.add(line)
            ptr = ptr.children[-1]
        elif line.depth == ptr.depth:
            ptr = ptr.parent
            ptr.add(line)
            ptr = ptr.children[-1]
        else:
            while line.depth < ptr.depth:
                ptr = ptr.parent
            ptr = ptr.parent
            ptr.add(line)
            ptr = ptr.children[-1]

    return root

# ------------------------------------------------
# -------- PROGRAM/AGENT/SUBAGENT OBJECTS --------
# ------------------------------------------------

class Program(object):
    def __init__(self,node):
        self.agent = {}
        for agent in node.children:
            code = agent.code

            if code[0].value == 'define':
                name = code[1].value
                self.buildAgent(name,agent)
            elif code[0].value == 'type':
                pass # TODO: implement types

    def buildAgent(self,name,agent):
        self.agent[name] = Agent(self,agent)

class Agent(object):
    def __init__(self,parent,node):
        self.parent = parent
        self.subagent = {}
        for subagent in node.children:
            code = subagent.code

            assert(code[0].tag in ['raw','init','run'])

            name = code[0].value
            self.buildSubagent(name,subagent)

        self.scope = {}

    def buildSubagent(self,name,subagent):
        self.subagent[name] = Subagent(self,subagent)

    def getVar(self,name):
        assert(name.startswith('self.'))
        assert(name in self.scope.keys())
        return self.scope[name]

    def setVar(self,name,val):
        assert(name.startswith('self.'))
        self.scope[name] = val

class Subagent(object):
    def __init__(self,parent,node):
        self.parent = parent
        self.scope = {}

        self.queue = deque()
        self.code = buildStructure(node.children,self)

    def exe(self):
        for c in self.code:
            c.exe()

    def getVar(self,name):
        if name.startswith('self.'):
            return self.parent.getVar(name)
        else:
            assert(name in self.scope.keys())
            return self.scope[name]

    def setVar(self,name,val):
        if name.startswith('self.'):
            return self.parent.setVar(name,val)
        else:
            self.scope[name] = val

    def sendMsg(self,dest,msg):
        pass # TODO


# --------------------------------------------
# -------- LOOP/IF/SWITCH/ETC OBJECTS --------
# --------------------------------------------





# TODO: implement toy 'send'/'assign' examples

def buildStructure(a,b):
    return None










































